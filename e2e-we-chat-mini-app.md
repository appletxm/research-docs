
![about us](images/a.png)

Our team has been working on we-chat miniprogram for a long time. With more and more functions developed, the regression test is becoming more and more frequently. Therefore, we decided to use automated testing to reduce the pressure of regression testing. At the same time, it can also be used as a tool for daily accessibility inspection of our applications. Without more words, we will get to the point immediately.

## 1. Solution Define
The solution should covered following requirements
1. E2E test for we-chat miniprogram native pages
2. E2E test for web-view pages
3. Test framework selection
4. Communication between native page and web-view page
5. Output test results (Excel, HTML)
6. Collection of error information

### 1.1 E2E test for we-chat miniprogram native pages
There are no much more solutions can be used on we-chat miniprogram. After a discussion within the team, we finally decided to use the officially provided tool [miniprogram automator](https://www.npmjs.com/package/miniprogram-automator), you can check more details from [official document](https://developers.weixin.qq.com/miniprogram/dev/devtools/auto/quick-start.html), this is a tool based on nodejs, so it is easy for us to get started. Here, I would like to thank our test engineer for their support. She was forced to use js to write automated tests. Thank you again.

After checking the official documents, I found that the `miniprogram Automator` is actually a castrated [puppeter](https://github.com/puppeteer/puppeteer), so i think people who have used puppeter should be familiar with it.

### 1.2 E2E test for web-view pages
For the automation of web-view, we choose [puppeter](https://github.com/puppeteer/puppeteer), you can also view the [Chinese api documentation](https://zhaoqize.github.io/puppeteer-api-zh_CN/#/), this is a module based on nodejs. It can offer all the apis and functions which we need. At the same time, Microsoft launched [playwright](https://github.com/microsoft/playwright)It's also a good choice, but since it's too new and needs take time to understand and try, so let's use puppeteer first, if we have time we will try it in future.

Specifically, we use the nodejs module `puppeter core`, because we don't want to install an additional browser when installing project dependencies. This process takes too much time, and there is a risk of unsuccessful installation. Therefore, we can directly install `puppeter core`, and then use the installed browser by using the configuration. For the specific difference from `puppeter`, we can view [puppeter vs puppeter core](https://github.com/puppeteer/puppeteer/blob/main/docs/api.md#puppeteer-vs-puppeteer-core).

### 1.3 Test framework
There are many good test frameworks to choose, like [jest](https://jestjs.io/), [mocka]( https://mochajs.bootcss.com/), [jasmine](https://jasmine.github.io/) and so on. We chose `jest`, which is relatively simple and the documents are also good.

### 1.4 Test result showing
We expect the test results to be output in Excel and online HTML preview, so we need to use the custom `reporter` configuration item of `jest` to register hook events, and we can receive the test results after the test is completed. See the official website [jest custom reporter](https://jestjs.io/docs/configuration#reporters-arraymodulename--modulename-options) for details.

### 1.5 Collection of error information
While we collect the test results, we still need to pay attention to the specific information of those test cases that go wrong. Jest returns the test error information in this part, but the returned format is' `ansi`, which is not friendly for display. Therefore, we need to introduce another module [`ansi-to-html`](https://www.npmjs.com/package/ansi-to-html), which can easily convert ansi into html.

### 1.6 Comunication between native page and web-view
Our web-view url needs to be generated by the native page, in order to ensure that the web-view can directly use these addresses, we use a temporary text file to store these address information. When the puppeter loads these pages, we will look in the temporary text file.

### 1.7 Solution
As above research, we get our E2E test framwork as below:

![solution diagram](https://image-static.segmentfault.com/323/484/3234840757-623820c981394_fix732)


## 2. Solution implementation

### 2.1 Configure we-chat dev-tool
When using the offical `miniprogram-automator` tool, we need to complete the following configurations

1. Configure the cli directory of the dev-tool. This directory is generally under the installation directory of the dev-tool, and the path address separator needs to use `/` whether window or Mac, such as `path/to/cli`

2. Configure the address of the miniprogram code

```javascript
// sample of windows configuration 

{
  projectPath: 'D:/project/code/product/mini-app/dist',
  cliPath: 'F:/ssd programs/微信web开发者工具/cli.bat'
}
```

```javascript
// sample of mac configuration

{
 projectPath: "/Users/nb666/Desktop/me/project/product/code/mini-app/dist",
 cliPath: "/Applications/wechatwebdevtools.app/Contents/MacOS/cli"
}
```

3. Open E2E service port for dev-tool

![config dev-tools](https://image-static.segmentfault.com/217/118/2171188632-623814b95d72a_fix732)


### 2.2 Configure puppeteer

Because we use `puppeter-core`, so we need to specify an additional browsing tool for it. I already installed chrome locally, so I need to configure the chrome exe file to puppeteer-core. However, according to the official instructions, any browser with dev-tools can be used as its running browser, including firefxo and edge.

```javascript
// smaple of our project

puppeteerCfg: {
    browserConfig: {
      executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      headless: false,
      ignoreHTTPSErrors: true,
      devtools: true,
      defaultViewport: {
        width: 1440,
        height: 900,
      },
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox'
      ]
    },
    pageConfig: {
      waitUntil: 'networkidle0',
      timeout: 0
    },
    mockDevice: 'iPhone 6'
  }
```

### 2.3 Configure jest
For the configuration of jest, in addition to the common ones, we also need to configure the collection script of customize test results of the above "1.4 Test result showing".

![jest report](https://segmentfault.com/img/bVcYC06)
configure jes.config.js file reporters item


![report.sj](https://segmentfault.com/img/bVcYC1p)
jest-repoerter.js

After the above configurations, we can get the test results after each test, but we also need to modify the content of the results. For the requirement of outputting Excel files, we use [exceljs](https://www.npmjs.com/package/exceljs). To output online viewing, we will directly send the test results to the corresponding browser through `web score` or `SSE(server sent events)`.

```javascript
// sample of jest.config.js

module.exports = {
  moduleFileExtensions: [
    'js',
    'html',
    'json'
  ],
  transform: {
    '^.+\\.js$': 'babel-jest'
  },
  moduleDirectories: [
    'node_modules'
  ],
  moduleFileExtensions: ['js', 'json', 'html', 'scss', 'css'],
  moduleNameMapper: {
    '\\.(jpg|jpeg|png|gif|eot|otf|webp|svg|ttf|woff|woff2|mp4|webm|wav|mp3|m4a|aac|oga|less|css)$': '<rootDir>/test/mocks/mock-file.js'
  },
  testMatch: ['<rootDir>/test/**/*.spec.js'],
  globals: {
    '__DEV__': true,
    '__ENV__': 'TEST'
  },
  globalSetup: '<rootDir>/scripts/jest-global-setup.js',
  globalTeardown: '<rootDir>/scripts/jest-global-teardown.js',
  reporters: ["default", "<rootDir>/scripts/jest-report.js"]
}
```

### 2.4 Coding of E2E test cases
For the codeing of E2E, we use ES6, so we need to set the `transform` configuration item in the above jet configuration. Then we list how to realize automatic code writing based on `puppeter-core` and `miniprogram-automator` respectively. I believe you will understand.

1. sample of using `miniprogram-automator`

This is a smaple for test `login` button, after click button whether can redirect to login page.

```javascript
const automator = require('miniprogram-automator')
const waitTime = require('../scripts/util-wait-time')
const { wsEndpoint } = require('../config')
const { loadedLoginPage } = require('./test-login-models')

jest.setTimeout(120 * 1000) // jest maximun duration for executed all of the test cases in current file

describe('User Login', () => {
  let miniProgram = null
  let page = null

  beforeAll(async () => {
    miniProgram = await automator.connect({
      wsEndpoint
    })

    page = await miniProgram.currentPage() // the first page will be loaded by defaualt

    await page.waitFor(async () => {
      const locaNode = await page.$$('.search-name')
      return locaNode.length > 0
    })
  })

  it('should open login page after click the entry ad. in home page', async () => {
    const enteryNode = await page.$('.ad-banner-image')
    await enteryNode.tap()

    await waitTime(5000) // give the enought time for dev-tool load page

    const { loginButton } = await loadedLoginPage(miniProgram)
    expect(loginButton.length).toBeGreaterThan(0)
  })

  afterAll(async () => {
    await mockLocation.doRestore({ miniProgram })

    await miniProgram.close()
    page = null
    miniProgram = null
    await waitTime(3000)
  })
})
```

2. Sample of using `puppeteer-core`


```javascript
// config.js

{
puppeteerCfg: {
    browserConfig: {
      executablePath: 'C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe',
      headless: false,
      ignoreHTTPSErrors: true,
      devtools: true,
      defaultViewport: {
        width: 1440,
        height: 900,
      },
      args: [
        '--no-sandbox',
        '--disable-setuid-sandbox'
      ]
    },
    pageConfig: {
      waitUntil: 'networkidle0',
      timeout: 0
    },
    mockDevice: 'iPhone 6'
  }
}
```

```javascript
//puppeter-opts.js

const puppeteer = require('puppeteer-core')
const { puppeteerCfg } = require('../config')
const { browserConfig, pageConfig, mockDevice } = puppeteerCfg
const allDevices = puppeteer['devices']

let wsEnd = null
let browser = null

async function createBrowser() {
  if (!wsEnd) {
    browser = await puppeteer.launch(browserConfig)
    wsEnd = browser.wsEndpoint()
  } else {
    browser = await puppeteer.connect({
      browserWSEndpoint: wsEnd
    })
  }

  return browser
}

async function createPage(passedBrowser, linkUrl, customize) {
  const phone = allDevices[mockDevice || 'iPhone 6']
  const pages = await passedBrowser.pages()
  const page = pages[0]
  await page.emulate(phone)

  if (customize && typeof customize === 'function') {
    await page.goto(linkUrl)
    await customize(page)
  } else {
    await page.goto(linkUrl, customize || pageConfig)
  }

  return page
}

async function closeBrowser() {
  if (browser) {
    await browser.close()
    browser = null
  }
  if (wsEnd) {
    wsEnd = null
  }
}

module.exports = {
  createBrowser,
  createPage,
  closeBrowser
}
```


```javascirpt
// test.js

const { createBrowser, createPage } = require('../scripts/puppeteer-opts')
const { getStringFromTmpFile } = require('../scripts/tmp-file-opts')
const waitTime = require('../scripts/util-wait-time')
const { customInfo } = require('../config')
const { waitSSOcall } = require('./test-aa-models')

let linkUrl = null
let browser = null
let page = null

const inputInfo = customInfo

jest.setTimeout(300 * 1000)

describe('Puppeteer Sample', () => {
  beforeAll(async () => {
    const otaDeepLink = getStringFromTmpFile('otaDeepLink')
    linkUrl = otaDeepLink

    console.log('**link from cache**', linkUrl)

    browser = await createBrowser()
    page = await createPage(browser, linkUrl, {
      waitUntil: 'domcontentloaded',
      timeout: 5 * 60 * 1000
    })

    await waitSSOcall(page, '/um/v2/users/')
  })

  it('should open search result page success', async () => {
    const listNodes = await page.$$('a[class^=Button__ButtonContainer]')
    console.log('**search list leng**', listNodes.length)
    expect(listNodes.length).toBeGreaterThanOrEqual(1)
  })

  afterAll(async () => {
    await browser.close()
    page = null
    browser = null
  })
})
```

### 2.5 Implementation E2E test cases
We set the jest configuration file `testmatch: ['< rootdir >/test/**/*.spec.js']` to let jest collect data under a specific directory , and all files which get the suffix like `.spec` will be contained. In essence, there is no need for human intervention in the order of collection and execution, but if we have the requirements for the execution order, we need to use additional files to control the execution order, as shown in the below screenshot `index.spec.js` realizes the control of two test files executed in sequence.

![e2e test](https://segmentfault.com/img/bVcYEJa) 


## 3. Test Result
Result with excel

![excel report](https://segmentfault.com/img/bVcYD2E)

Result with html

![html report](https://segmentfault.com/img/bVcYD2D)

Error info showing

![error show](https://segmentfault.com/img/bVcYENP)


## 4. Notice ⚠️⚠️
1. All authorizations need to be triggered manually and completed in advance
2. The element selector can only support elements and styles, and cannot have multiple levels
3. Select the element below the custom component. You need to prefix the style with the component name
4. Web view cannot be overwritten
5. You can only use dev tool as the automatic test terminal after scanning the code and logging in





